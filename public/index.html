<!doctype html>
<html lang="en" style="height:100%" >
    <head>
      <title>Good Game.</title>
      <style>
			     body { margin: 0; }
			     canvas { display: block; }

         #info
         {
	          position: absolute;
	          top: 10px;
	          width: 100%;
	          text-align: center;
	          z-index: 100;
	          display:block;
            color:white;
          }
		  </style>
    </head>

    <body>
        <div id="info">Description</div>
        <script src="js/three.js"></script>
		      <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            console.log("camera film width: "+camera.getFilmWidth());
            var ballVelocity = new THREE.Vector3();
            ballVelocity.set(0.0,0.0,0.0);
            var gCollisionPlanes = [];
            var preMouseX = 0.0;
            var preMouseY = 0.0;
            var newMouseX = 0.0;
            var newMouseY = 0.0;
            var mousePosVec = new THREE.Vector3();
            var mouseVelocity = new THREE.Vector3();

            var bumperGeometry = new THREE.TorusGeometry(0.5, 0.2, 8, 12/*16, 100*/);
            var bumperMaterial = new THREE.MeshPhongMaterial({color: 0x0000ff});
            var bumper = new THREE.Mesh(bumperGeometry, bumperMaterial);
            scene.add(bumper);
            bumper.position.z = 0.0;

            var currentRayMouseX = 0.0;
            var currentRayMouseY = 0.0;

            var prevdX = 0.0;
            var prevdY = 0.0;
            var dX = 0.0;
            var dY = 0.0;

            var collisionSphere = new THREE.Sphere(new THREE.Vector3(0.0, 0.0, 0.0), 0.2);
            //console.log("collisionSphere.center: "+collisionSphere.center);
            var collisionRightPlane = new THREE.Plane(new THREE.Vector3(-1.0, 0.0, 0.0));
            var collisionUnprojected = new THREE.Plane(new THREE.Vector3(-1.0, 0.0, 0.0));
            collisionUnprojected.translate(new THREE.Vector3(1.0, 0.0, 0.0));

            var maxXVector = new THREE.Vector3(1.0, 0.0, 0.0);
            var maxXValue = maxXVector.project(camera).x;

            var mouseVelRaycaster = new THREE.Raycaster();

            mouseVelocity.set(0.0, 0.0, 0.0);

            var mouseVelMat = new THREE.LineBasicMaterial({ color: 0x0000ff });
            var mouseVelPoints = [];
            mouseVelPoints.push(new THREE.Vector3(0.0, 0.0, 0.0));
            mouseVelPoints.push(new THREE.Vector3(0.0, 0.0, 0.0));
            var mouseVelGeometry = new THREE.BufferGeometry();
            mouseVelGeometry.setFromPoints(mouseVelPoints);

            var mouseVelLine = new THREE.Line(mouseVelGeometry, mouseVelMat);

            var collisionMat = new THREE.LineBasicMaterial({color: 0xff0000});
            var collisionPoints = [];
            collisionPoints.push(new THREE.Vector3(0.0, 0.0, 0.0));
            collisionPoints.push(new THREE.Vector3(0.0, 0.0, 0.0));
            var collisionGeometry = new THREE.BufferGeometry();
            var collisionLine = new THREE.Line(collisionGeometry, collisionMat);
            collisionGeometry.setFromPoints(collisionPoints);
            scene.add(collisionLine);


          var renderer = new THREE.WebGLRenderer();
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );

          var geometry = new THREE.SphereGeometry(radius=0.2);
          geometry.computeFaceNormals();

          //var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          var material = new THREE.MeshPhongMaterial( {color: 0x00ff00} )
          var cube = new THREE.Mesh( geometry, material );
          cube.position.z = 0.0;
          scene.add( cube );
          scene.add( mouseVelLine );

          // const color = 0xFFFFFF;
          // const intensity = 1;
          // const light = new THREE.DirectionalLight(color, intensity);
          // light.position.set(0, 0, 5.0);
          // light.target.position.set(0, 0, 0);
          // scene.add(light);
          // scene.add(light.target);

          var light = new THREE.AmbientLight( 0x404040 ); // soft white light

          scene.add( light );

          const color = 0xFFFFFF;
          const intensity = 1;
          const dirLight = new THREE.DirectionalLight(color, intensity);
          dirLight.position.set(0, 0, 5.0);
          dirLight.target.position.set(-5.0, -3.0, 0);
          scene.add(dirLight);
          scene.add(dirLight.target);

          const dirLight2 = new THREE.DirectionalLight(color, intensity);
          dirLight2.position.set(0, 0, 5.0);
          dirLight2.target.position.set(5.0, 3.0, 0);
          scene.add(dirLight2);
          scene.add(dirLight2.target);


          constructFieldPlanes(scene);
          constructCollisionPlanes();

          camera.position.z = 5;
          renderer.render( scene, camera );

          console.log("max x: "+maxXValue);
          var screenBounds = getScreenBounds();
          console.log("setting right plane at: "+screenBounds.x);
          collisionRightPlane.translate(new THREE.Vector3(screenBounds.x, 0.0, 0.0));

          function constructCollisionPlanes()
          {
            var topPlane = new THREE.Plane(new THREE.Vector3(0.0, -1.0, 0.0));
            topPlane.translate(new THREE.Vector3(0.0, 3.0, 0.0));

            var rightPlane = new THREE.Plane(new THREE.Vector3(-1.0, 0.0, 0.0));
            rightPlane.translate(new THREE.Vector3(5.0, 0.0, 0.0));

            var bottomPlane = new THREE.Plane(new THREE.Vector3(0.0, 1.0, 0.0));
            bottomPlane.translate(new THREE.Vector3(0.0, -3.0, 0.0));

            var leftPlane = new THREE.Plane(new THREE.Vector3(1.0, 0.0, 0.0));
            leftPlane.translate(new THREE.Vector3(-5.0, 0.0, 0.0));
            gCollisionPlanes.push(topPlane);
            gCollisionPlanes.push(rightPlane);
            gCollisionPlanes.push(leftPlane);
            gCollisionPlanes.push(bottomPlane);
          }

          function constructFieldPlanes(scene)
          {
            //var fieldMaterial = new THREE.MeshBasicMaterial({color: 0x34cceb, side: THREE.DoubleSide});
            var fieldMaterial = new THREE.MeshPhongMaterial({color: 0x34cceb, side: THREE.DoubleSide})
            var topFieldPlane = new THREE.PlaneGeometry(10, 0.5);
            var topPlane = new THREE.Mesh(topFieldPlane, fieldMaterial);
            topPlane.translateY(3.0);
            topPlane.rotateX(Math.PI/2.0);

            bottomFieldPlane = new THREE.PlaneGeometry(10, 0.5);
            var bottomPlane = new THREE.Mesh(bottomFieldPlane, fieldMaterial);
            bottomPlane.translateY(-3.0);
            bottomPlane.rotateX(Math.PI/2.0);
            scene.add(bottomPlane);

            var leftFieldPlane = new THREE.PlaneGeometry(6, 0.5);
            var leftPlane = new THREE.Mesh(leftFieldPlane, fieldMaterial);
            leftPlane.translateX(-5.0)
            leftPlane.rotateZ(Math.PI/2.0);
            leftPlane.rotateX(Math.PI/2.0);

            var rightFieldPlane = new THREE.PlaneGeometry(6, 0.5);
            var rightPlane = new THREE.Mesh(rightFieldPlane, fieldMaterial);
            rightPlane.translateX(5.0);
            rightPlane.rotateZ(Math.PI/2.0);
            rightPlane.rotateX(Math.PI/2.0);

            var floorMaterial = new THREE.MeshPhongMaterial({color: 0x525252, side: THREE.DoubleSide})
            var floorFieldPlane = new THREE.PlaneGeometry(10, 6);
            var floorPlane = new THREE.Mesh(floorFieldPlane, floorMaterial);
            floorPlane.translateZ(-0.25);
            scene.add(floorPlane);

            scene.add(rightPlane);
            scene.add(leftPlane);
            scene.add(topPlane);
          }

          var ballRaycaster = new THREE.Raycaster();

          //var infoDiv = document.getElementById("info");
          function animate() {
	           requestAnimationFrame( animate );
             ballRaycaster.setFromCamera({x:currentRayMouseX, y:currentRayMouseY}, camera);

             if(bumperGeometry.boundingSphere.intersectsSphere(collisionSphere))
             {
               console.log("bumper hit ball!");
              if(mouseVelocity)
              {
                var bumperVel = new THREE.Vector3()
                bumperVel.copy(mouseVelocity);

                var tangentVector = new THREE.Vector3();
                tangentVector.y = -(collisionSphere.center.x - bumper.position.x);
                tangentVector.x = (collisionSphere.center.y - bumper.position.y);
                tangentVector.normalize();

                var relVelocity = new THREE.Vector3();
                relVelocity.x = mouseVelocity.x - ballVelocity.x;
                relVelocity.y = mouseVelocity.y - ballVelocity.y;
                var length = relVelocity.dot(tangentVector);
                var componentOnTangent = new THREE.Vector3();
                componentOnTangent.copy(tangentVector);
                componentOnTangent.multiplyScalar(length);
                var componentOffTangent = new THREE.Vector3();
                componentOffTangent.copy(relVelocity);
                componentOffTangent.sub(componentOnTangent);
                ballVelocity.x += componentOffTangent.x;
                ballVelocity.y += componentOffTangent.y;


              }

             }
            var mouseIntersecting = ballRaycaster.intersectObjects([cube]);

             if(mouseIntersecting.length > 0)
             {
               //this works! now we have to figure out the richochet off the face... \n
               var ballCollision = mouseIntersecting[0];
               var collisionFace = ballCollision.face;
               var faceNormal = collisionFace.normal;
               var mouseVel = new THREE.Vector3();
               mouseVel.copy(mouseVelocity);

               var uVector = mouseVel.clone()
               uVector.dot(faceNormal);

               uVector.multiply(mouseVel);

               var wVector = mouseVel.clone()
               wVector.sub(uVector);

               var vPrime = mouseVel.clone();
               vPrime.sub(uVector);

               if(mousePosVec)
               {
                 //console.log("collision vector updated.");
                 collisionPoints[0].set(mousePosVec.x, mousePosVec.y, mousePosVec.z);
                 collisionPoints[1].set(mousePosVec.x + vPrime.x, mousePosVec.y + vPrime.y, mousePosVec.z + vPrime.z);
                 console.log("start: ("+collisionPoints[0].x+", "+collisionPoints[0].y+", "+collisionPoints[0].z+")");
                 console.log("end: ("+collisionPoints[1].x+", "+collisionPoints[1].y+", "+collisionPoints[1].z+")");
                 collisionGeometry.setFromPoints(collisionPoints);
               }else{
                 console.log("mousePosVec is null!");
               }


             }

             var cubePos = cube.position;
             camera.updateMatrix();
             camera.updateMatrixWorld();
             var frustum = new THREE.Frustum();
             frustum.setFromProjectionMatrix(new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));

             collisionSphere.center.x = cubePos.x;
             collisionSphere.center.y = cubePos.y;
             cube.translateX(ballVelocity.x);
             cube.translateY(ballVelocity.y);

             //top plane
              if(gCollisionPlanes[0].intersectsSphere(collisionSphere))
              {
                while(gCollisionPlanes[0].intersectsSphere(collisionSphere))
                {
                  collisionSphere.center.y -= 0.01;
                }
                cube.position.y = collisionSphere.center.y;

                ballVelocity.y = -ballVelocity.y;
              }

              if(gCollisionPlanes[3].intersectsSphere(collisionSphere))
              {
                while(gCollisionPlanes[3].intersectsSphere(collisionSphere))
                {
                  collisionSphere.center.y += 0.01;
                }
                cube.position.y = collisionSphere.center.y;

                ballVelocity.y = -ballVelocity.y;
              }

             if(gCollisionPlanes[1].intersectsSphere(collisionSphere))
             {
               console.log("Sphere intersecting with right plane!");
               while(gCollisionPlanes[1].intersectsSphere(collisionSphere))
               {
                 collisionSphere.center.x -= 0.01;
               }
               cube.position.x = collisionSphere.center.x;

               ballVelocity.x = -ballVelocity.x;
             }

             if(gCollisionPlanes[2].intersectsSphere(collisionSphere))
             {

               while(gCollisionPlanes[2].intersectsSphere(collisionSphere))
               {
                 collisionSphere.center.x += 0.01;
               }
               cube.position.x = collisionSphere.center.x;

               ballVelocity.x = -ballVelocity.x;

               console.log("Sphere intersecting with left plane!");
             }




	           renderer.render( scene, camera );
            }
            animate();

            function getScreenBounds()
            {
              var maxBounds = new THREE.Vector3();
              maxBounds.set(1.0, 1.0, -1.0);
              var maxBoundsDistance = (camera.position.z) / maxBounds.z;

              maxBounds.unproject(camera);
              maxBounds.sub(camera.position).normalize();
              var maxBoundsVec = new THREE.Vector3();
              maxBoundsVec.copy(camera.position).add(maxBounds.multiplyScalar(maxBoundsDistance));

              console.log("maxBounds.x: "+maxBoundsVec.x);
              return maxBoundsVec;
            }

            window.addEventListener("mousemove", function(event) {
              //console.log("mouse moved!");
              var x = (event.clientX / window.innerWidth) * 2 - 1;
              var y = - (event.clientY / window.innerHeight) * 2 + 1;
              currentRayMouseX = x;
              currentRayMouseY = y;
              //console.log("original x: "+x);
              var mouseVec = new THREE.Vector3();
              mouseVec.set(x, y, 0.75);

              mouseVec.unproject(camera);

              mouseVec.sub(camera.position).normalize();

              var distance = camera.position.z / mouseVec.z;

              var posVec = new THREE.Vector3();

              posVec.copy(camera.position).add(mouseVec.multiplyScalar(distance));
              mousePosVec.set(posVec.x, posVec.y, posVec.z);
              preMouseX = newMouseX;
              preMouseY = newMouseY;
              newMouseX = -posVec.x;
              newMouseY = -posVec.y;

              bumper.position.x = newMouseX;
              bumper.position.y = newMouseY;
              bumperGeometry.boundingSphere.center.x = newMouseX;
              bumperGeometry.boundingSphere.center.y = newMouseY;

              prevdX = dX;
              prevdY = dY;
              dX = newMouseX - preMouseX;
              dY = newMouseY - preMouseY;
              mouseVelocity.x = dX;
              mouseVelocity.y = dY;


              var multVel = mouseVelocity.multiplyScalar(5);
              if(Math.abs(multVel.x) >= 0.1 && Math.abs(multVel.y) > 0.1)
              {
                mouseVelPoints[0].x = newMouseX;
                mouseVelPoints[0].y = newMouseY;
                mouseVelPoints[1].x = newMouseX + multVel.x;
                mouseVelPoints[1].y = newMouseY + multVel.y;
                //console.log("end x: "+multVel.x+", end y: "+multVel.y);
                mouseVelGeometry.setFromPoints(mouseVelPoints);
              }
              mouseVelRaycaster.set(mouseVelPoints[0].normalize(), mouseVelPoints[1].normalize());

              var intersects = mouseVelRaycaster.intersectObjects(scene.children);
              if(intersects.length > 0)
              {
                for(var i = 0; i < intersects.length; i++)
                {
                  var intersected = intersects[i];
                  var object = intersected.object;
                  if(object.id == cube.id)
                  {
                    //this works
                    console.log("ball was intersected!");
                  }
                }
                //console.log("mouse velocity vector insersects "+intersects.length+" item(s). ");

              }


              //ray cast with mouse velocity, get face it intersects with, do math to transfer velocity.

              //console.log("x: "+x+", y: "+y);
              document.getElementById("info").innerHTML = "mouse: x: "+newMouseX.toFixed(3)+", y: "+newMouseY.toFixed(3);
            })
		  </script>
    </body>

</html>
